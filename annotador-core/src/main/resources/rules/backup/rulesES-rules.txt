

#####################
# Basics (numbers)
#####################

{ ruleType:   "tokens",
    pattern: ( ([{pos:"Z"}]) ) ,
	action: ( Annotate($0, "myRule", "Rule$ZNumber"), Annotate($0, "myNUM", "myNUMBER"), Annotate($0, "mySTValue", $$1.lemma), Annotate($0, "myNERnormalized", :case{($$1.lemma.length == 1) => Concat("0", $$1.lemma), :else => $$1.lemma}) ),
	stage : 1 }

{ ruleType:   "tokens",
    pattern: ( ([{word:/\d+/}]) ) ,
	action: ( Annotate($0, "myRule", "Rule$DNumber"), Annotate($0, "myNUM", "myNUMBER"), Annotate($0, "mySTValue", $1[0].lemma), Annotate($0, "myNERnormalized", :case{($1[0].lemma.length == 1) => Concat("0", $1[0].lemma), :else => $1[0].lemma}) ),
	stage : 1 }

# CHECK mirar que no se quede sola la y
# eg: mil cuatrocientos dieciseis
{ ruleType:   "tokens",
    pattern: ( (?$yearunsdig [{lemma:/$UNSDIG/} & !{pos:/DI.*/}])? (?$yeardig [{lemma:/$YEARDIG/}])? (?$centdig [{lemma:/$CENTDIG/}])? (?$decsdig [{lemma:/$DECSDIG/}])? (?$specialsdig [{lemma:/$SPECIALSDIG/}])? ((?$gry [{lemma:"y"}]) (?$unsdig [{lemma:/$UNSDIG/}]))?),
	action: ( :case{ ($0[0].lemma != "y") =>
	
	(Annotate($0, "myRule", "Rule$LONGNUMBER"), Annotate($0, "myNUM", "myNUMBER"), Annotate($0, "mySTValue", Format("%d", Add( 
	:case { # We look at the Year digit
		($$yearunsdig == NIL && $$yeardig == NIL) => 0,
		($$yearunsdig == NIL && $$yeardig != NIL) => YEARS_MAP[$yeardig[0].lemma] ,		
		($$yearunsdig != NIL && $$yeardig != NIL) => Multiply(UNS_MAP[$yearunsdig[0].lemma],YEARS_MAP[$yeardig[0].lemma]) ,		
		:else => UNS_MAP[$yearunsdig[0].lemma]} , Add( #Special case, is a unit!
		:case {  # We look at the Century digit
			($$centdig == NIL ) => 0 ,
			:else => CENTS_MAP[$centdig[0].lemma]}, Add(
				:case { # We look at the Decade digit
					($$decsdig == NIL && $$specialsdig == NIL) => 0 ,
					($$decsdig == NIL && $$specialsdig != NIL) => SPECIALS_MAP[$specialsdig[0].lemma] ,
					($$decsdig != NIL && $$specialsdig == NIL) => DECS_MAP[$decsdig[0].lemma] ,
					:else => 0},  
						:case {  # We look at the Unit digit
							($$unsdig == NIL ) => 0 ,
							:else => UNS_MAP[$unsdig[0].lemma]}
				)
			)
		))
	), Annotate($0, "myNERnormalized", :case{($0[0].mySTValue.length == 1) => Concat("0", $0[0].mySTValue), :else => $0[0].mySTValue})
	 );}),
	stage : 4 }

	
#####################
# Time-related basics (weekdays, months...)
#####################

{ ruleType:   "tokens",
  pattern: ( $MONTHS ),
  action: ( Annotate($0, "myRule", "Rule$MONTHS"), Annotate($0, "myNER", "MONTHS"), Annotate($0, "myNERnormalized", Format("%02d", $$0.value)), Annotate($0, "mySTValue", Format("%d", $$0.value)), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat("XXXX-",Format("%02d", $$0.value)) )) ,
  stage : 1  } 
  
{ ruleType:   "tokens",
  pattern: ( $WEEKL ),
  action: ( Annotate($0, "myRule", "Rule$WEEKL"), Annotate($0, "myNER", "WEEKDAY"), Annotate($0, "myNERnormalized", Format("%02d", $$0.value)), Annotate($0, "mySTValue", Format("%d", $$0.value) ), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat("XXXX-WXX-", Format("%02d", $$0.value))) ) ,
  stage : 1  } 
  
{ ruleType:   "tokens",
  pattern: ( $DAYMONTHN ),
  action: ( Annotate($0, "myRule", "Rule$DAYMONTHN"), Annotate($0, "myNER", "DAYMONTH"), Annotate($0, "myNERnormalized", Format("%02d", $$0.value)), Annotate($0, "mySTValue", Format("%d", $$0.value) ), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Format("%02d", $$0.value)) ) ,
  stage : 1  } 
  
{ ruleType:   "tokens",
  pattern: ( $MONTHN ),
  action: ( Annotate($0, "myRule", "Rule$MONTHN"), Annotate($0, "myNER", "MONTHN"), Annotate($0, "myNERnormalized", Format("%02d", $$0.value)) , Annotate($0, "mySTValue", Format("%d", $$0.value) ), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Format("%02d", $$0.value)) ) ,
  stage : 1  } 
  
{ ruleType:   "tokens",
  pattern: ( $YEARN ),
  action: ( Annotate($0, "myRule", "Rule$YEARN"), Annotate($0, "myNER", "YEAR"), Annotate($0, "myNUM", "myNUMBER"), Annotate($0, "myNERnormalized", $$0.text), Annotate($0, "mySTValue", $$0.text) , Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", $$0.text) ) ,
  stage : 1  }


{ ruleType:   "tokens",
  pattern: ( [{lemma:/$UNSDIG/}] ),
  action: ( Annotate($0, "myRule", "Rule$LetterNumber"), Annotate($0, "myNER", "myNUMBER"), Annotate($0, "myNUM", "myNUMBER"), Annotate($0, "mySTValue", Format("%d", UNS_MAP[$0[0].lemma])), Annotate($0, "myNERnormalized", Format("%02d", UNS_MAP[$0[0].lemma])) ) ,
  stage : 1  }  


#####################
# Years with letters
#####################


# eg: en el año mil cuarenta y dos
{ ruleType:   "tokens",
    pattern: ( (?: [{lemma:"de"}] | [{lemma:"del"}] | [{lemma:"en"}] | [{lemma:"a"}] | [{lemma:"el"} & !{pos:/DA0.P0/}] | [{lemma:"para"}]) (?: [{lemma:"el"} & !{pos:/DA0.P0/}]? [{lemma:"año"}]?) ([{myNUM:"myNUMBER"} && {mySTValue:/[12]\d\d\d/}]+ /[AaDd]\.?[Cc]\.?/?)),
	action: ( (Annotate($1, "myRule", "Rule$EnElAñoMyNumber"), Annotate($1, "myNER", "YEAR")), Annotate($1, "timexValue", $1[0].mySTValue), Annotate($1, "myNERnormalized", $1[0].mySTValue), Annotate($1, "timexType", "DATE")),
	stage : 5 }	

# It adds its value as a myNERnormalized String to any number written with words	
#{ ruleType:   "tokens",
#    pattern: ( ([{myNUM:"myNUMBER"} & {myNERnormalized:NIL}]+) ),
#	action: ( Annotate($0, "myRule", "Rule$myNUMBER"), Annotate($$1, "myNERnormalized", $1[0].mySTValue)),
#	stage : 4 }



  


  

#####################
# Others
#####################

# eg: fin de semana / fines de semana
{ ruleType:   "tokens",
  pattern: ( ([{lemma:"fin"}]|[{lemma:"fines"}]) [{lemma:"de"}] [{lemma:"semana"}] ),
  action: ( Annotate($0, "myRule", "Rule$FinDeSemana"), Annotate($0, "myNER", "DGRANULARITY"), Annotate($0, "myNERnormalized", DGRANULARITY_MAP["finsemana"] ), Annotate($0, "myTType", "finsemana" ) ) ,
  stage : 1  }

# eg: meses, dia...  
{ ruleType:   "tokens",
  pattern: ( [{lemma:/$DGranularity/} & !{myNER:"DGRANULARITY"}] ),
  action: ( Annotate($0, "myRule", "Rule$Granularity"), Annotate($0, "myNER", "DGRANULARITY"), Annotate($0, "myNERnormalized", DGRANULARITY_MAP[$0[0].lemma] ), Annotate($0, "myTType", $$0.text ) ) ,
  stage : 2  }




#####################
# References
#####################

# eg: References to the present
{ ruleType:   "tokens",
  pattern: ([{lemma:"actualmente"}] | ([{lemma:"ahora"}] [{lemma:"mismo"}]?) | ([{lemma:"hoy"}] [{lemma:"en"}] [{lemma:"día"}])),
  action: ( Annotate($0, "myRule", "Rule$PresentRef"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", "PRESENT_REF") )  ,
  stage : 1  }

  
# eg: References to the past (TODO: ese momento puede usarse en futuro, ver tiempos verbales...)
{ ruleType:   "tokens",
  pattern: (([{lemma:"en"}] [{lemma:"el"}] /pasado|PASADO/) | ([{lemma:"el"}] [{lemma:"ayer"}]) | ([{lemma:"en"}] ([{lemma:"aquel"}]| [{lemma:"ese"}] |[{lemma:"el"}]) ([{lemma:"momento"}]|[{lemma:"instante"}])) | ([{lemma:"antiguamente"}]) | ([{lemma:"antaño"}]) | (/hace|HACE/ [{lemma:"tiempo"}]) | (/hace|HACE/ /muchos|MUCHOS/ /años|AÑOS/)),
  action: ( Annotate($0, "myRule", "Rule$PastRef"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", "PAST_REF") )  ,
  stage : 1  }
  
# eg: References to the future (TODO: habria que meter "en unos + granularidad", ¿horas como?)
{ ruleType:   "tokens",
  action: ( Annotate($0, "myRule", "Rule$FutureRef"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", "FUTURE_REF") )  ,
  pattern: (([{lemma:"en"} | {lemma:"ser"}] [{lemma:"el"}] [{lemma:"futuro"}] (?:[!{pos:/NC.*/}]){0}) | ([{lemma:"el"}] ([{lemma:"día"}] [{lemma:"de"}])? [{lemma:"mañana"}]) | ([{lemma:"próximamente"}]) | ([{lemma:"en"}] /unos|UNOS/ [{lemma:"año"}]) | ([{lemma:"dentro"}] [{lemma:"de"}] /unos|UNOS/ /años|AÑOS/) | ([{lemma:"en"}] /los|LOS/ /próximos|PRÓXIMOS/ /años|AÑOS/) | ([{lemma:"en"}] /los|LOS/ /años|AÑOS/ /venideros|VENIDEROS/) | ([{lemma:"en"}] /los|LOS/ /años|AÑOS/ [{lemma:"que"}] /están|ESTÁN/ [{lemma:"por"}] [{lemma:"venir"}])),
  stage : 1  }

{ ruleType:   "tokens",
  pattern: (([{lemma:"anteanoche"}] | [{lemma:"antes"}] [{lemma:"de"}] [{lemma:"anoche"}])),
  action: ( Annotate($0, "myRule", "Rule$antesdeanoche"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", "anchor(TODAY,-2,DAY)TNI") )  ,
  stage : 1  }
  
{ ruleType:   "tokens",
  pattern: ([{lemma:"anoche"}]),
  action: ( Annotate($0, "myRule", "Rule$anoche"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", "anchor(TODAY,-1,DAY)TNI") )  ,
  stage : 1  }

  
#####################
# Anchored
#####################
 

# eg: Pasado mañana / pasado
{ ruleType:   "tokens",
  pattern: ((?:[!{pos:/D.*/}]) (([{lemma:"pasado"}] [{lemma:"mañana"}]) | ([{lemma:"pasado"} & !{pos:/V.*/} & !{pos:/A.*/} & !{timexValue:"PAST_REF"}])) (?:[!{pos:/NC.*/}]){0}),
  action: ( Annotate($0, "myRule", "Rule$PasadoMañana"), Annotate($1, "timexType", "DATE"), Annotate($1, "timexValue", "anchor(TODAY,+2,DAY)"), Annotate($1, "myNERnormalized", "PASADO_MAÑANA") )  ,
  stage : 3  }

# eg: mañana
{ ruleType:   "tokens",
  pattern: ([{lemma:"mañana"} & {pos:/RG.*/}]),
  action: ( Annotate($0, "myRule", "Rule$Mañana"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", "anchor(TODAY,+1,DAY)"), Annotate($0, "myNERnormalized", "MAÑANA") )  ,
  stage : 2  }
  
# eg: hoy
{ ruleType:   "tokens",
  pattern: (([{lemma:"a"}] [{lemma:"día"}] [{lemma:"de"}])? [{lemma:"hoy"}]),
  action: ( Annotate($0, "myRule", "Rule$Hoy"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", "anchor(TODAY,0,DAY)"), Annotate($0, "myNERnormalized", "HOY") )  ,
  stage : 2  }
  
  
  
# eg: References to the present
{ ruleType:   "tokens",
  pattern: ([{lemma:"anteayer"}] | ([{lemma:"antes"}] [{lemma:"de"}] [{lemma:"ayer"}])),
  action: ( Annotate($0, "myRule", "Rule$Anteayer"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", "anchor(TODAY,-2,DAY)"), Annotate($0, "myNERnormalized", "ANTEAYER") )  ,
  stage : 2  }  

# eg: References to the present
{ ruleType:   "tokens",
  pattern: ([{lemma:"el"}]{0} [{lemma:"ayer"}]),
  action: ( Annotate($0, "myRule", "Rule$ElAyer"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", "anchor(TODAY,-1,DAY)"), Annotate($0, "myNERnormalized", "AYER") )  ,
  stage : 2  }  

  
  
  
#####################
# Parts of the day
#####################
 

# eg: Mañana, tarde (MODSTIME)
# String PDGranularityES = "(?:madrugada|mañana|tarde|tardenoche|noche)";
{ ruleType:   "tokens",
  pattern: ((?:[{pos:/D.*/} | {lemma:/al/} | {lemma:/del/} | {pos:/AQ.*/}]) ([{lemma:"madrugada"} | {lemma:"mañana"}  | {lemma:"tarde"} | {lemma:"tardenoche"} | {lemma:"mediodía"} | {lemma:"noche"} & {pos:/NC.*/} & !{timexValue:/.+/}])),
  action: ( Annotate($0, "myRule", "Rule$PARTDAY"), Annotate($0, "timexType", "TIME"), Annotate($0, "timexValue", PARTDAY_MAP[$1[0].lemma]), Annotate($0, "myNERnormalized", "PARTDAY") )  ,
  stage : 4  }
  
  
#####################
# SETS
#####################
 

# eg: Mensualmente
# String periodAdvES = GranularityES+"mente";
{ ruleType:   "composite",
  pattern: ([{lemma:/$PeriodAdv/} && !{pos:/N.*/}]),
  action: ( Annotate($0, "myRule", "Rule$GranMente"), Annotate($0, "timexType", "SET"), Annotate($0, "timexValue", PERIODMENTE_MAP[$0[0].lemma]), Annotate($0, "myNERnormalized", "SET_MENTE") )  ,
  result: ("SET", $0[0].timexValue, "", "", "Rule$GranMente"),
  stage : 1  }
  
# eg: Dos días cada 2 meses
{ ruleType:   "composite",
  pattern: ((?$times [{timexType:"DURATION"}]+) ([{lemma:"cada"}]) (?$gran [{timexType:"DURATION"}]+)),
  action: ( Annotate($0, "myRule", "Rule$XGranCadaXGran"), Annotate($0, "timexType", "SET"),  Annotate($0, "timexFreq", $times[0].timexValue), Annotate($0, "timexValue", $gran[0].timexValue) )  ,
  result: ("SET", $times[0].timexValue, $times[0].timexFreq, "", "Rule$XGranCadaXGran"),
  stage : 17  }
  
# eg: Dos días cada semana
{ ruleType:   "composite",
  pattern: ((?$times [{timexType:"DURATION"}]+)  (?: [{lemma:"cada"}] | [{lemma:"por"}] | [{lemma:"al"}] | [{lemma:"a"}]) (?: [{lemma:"la"}] | [{lemma:"el"}])? (?$gran [{myNER:"DGRANULARITY"}]+)),
  action: ( Annotate($0, "myRule", "Rule$XGranCadaGran"), Annotate($0, "timexType", "SET"),  Annotate($0, "timexFreq", $times[0].timexValue), Annotate($0, "timexValue", Concat(PERIOD_MAP[$gran[0].myNERnormalized],"01",DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized])), Annotate($0, "timexFreq", $times[0].timexValue) )  ,
  result: ("SET", $times[0].timexValue, $times[0].timexFreq, "", "Rule$XGranCadaGran"),
  stage : 16  }
  
# eg: (Dos veces) cada 2 meses
{ ruleType:   "composite",
  pattern: ((?$times [{myNER:"TIMES"}]+)? (?: [{lemma:"cada"}]) (?$gran [{timexType:"DURATION"} & !{timexValue:/anchor.*/}]+)),
  action: ( Annotate($0, "myRule", "Rule$XVezCadaXGran"), Annotate($0, "timexType", "SET"),  Annotate($0, "timexFreq", :case{ ($$times != NIL) => $times[1].myNERnormalized, :else => ""} ), Annotate($0, "timexValue", $gran[0].timexValue) )  ,
    result: ("SET", $0[1].timexValue, $0[1].timexFreq, "", "Rule$XVezCadaXGran"),
  stage : 18  }
  
# eg: (Dos veces) cada/por semana
{ ruleType:   "composite",
  pattern: ((?$times [{myNER:"TIMES"}]+)? (?: [{lemma:"cada"}] | [{lemma:"por"}] | [{lemma:"al"}] | [{lemma:"a"}]) (?: [{lemma:"la"}] | [{lemma:"el"}])? (?$gran [{myNER:"DGRANULARITY"} & !{timexValue:/anchor.*/}]+)),
  action: ( Annotate($0, "myRule", "Rule$XVezCadaGran"), Annotate($0, "timexType", "SET"), Annotate($0, "timexFreq", :case{ ($$times  != NIL) => $0[1].myNERnormalized, :else => ""} ) , Annotate($0, "timexValue", Concat(PERIOD_MAP[$gran[0].myNERnormalized],"1",DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized])) )  ,
    result: ("SET", $0[1].timexValue, $0[1].timexFreq, "", "Rule$XVezCadaGran"),
  stage : 18  }
  
# eg: Todas las semanas
{ ruleType:   "composite",
  pattern: (( [{lemma:"todo"} & {pos:/DI0.P0/}]) (?: [{pos:/DA0.P0/}]) ([{myNER:"DGRANULARITY"}]+)),
  action: ( Annotate($0, "myRule", "Rule$TodGran"), Annotate($0, "timexType", "SET"), Annotate($0, "timexValue", Concat(PERIOD_MAP[$2[0].myNERnormalized],"1",DGRANULARITY_UNIT_MAP[$2[0].myNERnormalized])) )  ,
  stage : 18  }

  





  
  
#####################
# Indefs
#####################

# eg: varios, algunos...
{ ruleType:   "tokens",
  pattern: ( ([{pos:/DI.*/} & (!{myNUM:"myNUMBER"} | {word:/unos|UNOS|Unos/})]+) [{pos:/A.*/}]*), 
  action: ( Annotate($0, "myRule", "Rule$Indef"), Annotate($0, "myNER", "INDEF") )  ,
  stage : 10  }

# eg: proximo
{ ruleType:   "tokens",
  pattern: ( ([{pos:/A.*/} & {lemma:/próximo|siguiente|posterior/}]+ | [{lemma:"que"}] [{word:/viene|VIENE/}]) ), 
  action: ( Annotate($0, "myRule", "Rule$FutureAdj"), Annotate($0, "myNER", "FUT_REF_Adj") )  ,
  stage : 9  }  
  
# eg: proximo
{ ruleType:   "tokens",
  pattern: ( ([{pos:/A.*/} & {lemma:/anterior|previo|último|precedente|pasado/}]+) ), 
  action: ( Annotate($0, "myRule", "Rule$PastAdj"), Annotate($0, "myNER", "PAS_REF_Adj") )  ,
  stage : 9  }  
  
# eg: demostrativo
{ ruleType:   "tokens",
  pattern: ( ([{pos:/DD.*/}]+) [{pos:/A.*/} & !{myNER:/.*_REF_Adj/}]*), 
  action: ( Annotate($0, "myRule", "Rule$Dem"), Annotate($0, "myNER", "DEM") )  ,
  stage : 10  }

#    String deictic2DurES = "(?:[M|m]uch[a|o]s|[U|u]n par de|[U|u]n[o|a]s cuant[o|a]s|[A|a]lgun[a|o]s|([U|u]n[a|o]s #)?[P|p]oc[a|o]s)";
#    String deictic1ES = #"(?:[E|e]l|[L|l]a|[L|l]os|[L|l]as|[E|e]s[e|a]|[E|e]st[e|a]|[E|e]s[o|a]s|[E|e]st[o|a]s|[A|a]quell[o|a]s|[A|a]quel|[P|p]asad[o|a](s#)?|[F|f]utur[o|a](s)?)";

#     //COMMENT
# 	String deictic1DurES = "(?:[E|e]l|[L|l]a|[L|l]os|[L|l]as|[E|e]s[e|a]|[E|e]st[e|a]|[E|e]s[o|a]s|[E|e]st[o|a]s|[A|a]quell[o|a]s|[A|a]quel|[P|p]asad[o|a](s)?|[F|f]utur[o|a](s)?)";
#     String deictES = "(" + deictic1ES + "|" + deictic2ES + "|" + deictic1ES + " " + deictic2ES + ")";
#     String deictDurES = "(((en el transcurso de|durante) )?" + deictic1DurES + "|" + deictic2DurES + "|" + deictic1DurES + " " + deictic2DurES + ")";



#####################
# Part day
#####################

# eg: mañana
{ ruleType:   "tokens",
  pattern: ([{lemma:"mañana"} & {pos:/NCS.*/}]), #Femenine for distinction with "el mañana" (unnecessary)
  action: ( Annotate($0, "myRule", "Rule$Mañ"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", "anchor(TODAY,+1,DAY)"), Annotate($0, "myNERnormalized", "MAÑANA") )  ,
  stage : 2  }

  
  
  
  
  
  
  
  
  
  
  
  
  
#####################
# Complex dates
#####################  
  #     String longDateES = "(" + dayMonthNES + " de " + monthLES + "(?: (?:de )?" + yearNES + "))";
  # eg: dos dias
#{ ruleType:   "tokens",
#  pattern: ( /el/? /dia/? ([{myNER:"DAYMONTH"} | {myNER:"MONTHN"}]) (?: /de/ | /del/) /mes/? /de/? ([{myNER:"MONTHS"}]) (?: /de/ | /del/ | /,/) /año/? ([{myNER:"YEAR"}])) ,
#  action: ( Annotate($0, "myRule", "Rule$DDdeMMdeYYYY"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat(:case{ ($$3 != NIL) => $3[0].myNERnormalized, :else => "XXXX"}, "-", :case{ ($$2 != NIL) => $2[0].myNERnormalized, :else => "XX"}, "-", :case{ ($$1 != NIL) => $1[0].myNERnormalized, :else => "XX"})) )  ,
#  stage : 11  }
  
  
#{ ruleType:   "tokens",
#  pattern: ( /el/? /mes/? /de/? ([{myNER:"MONTHS"}]) (?: /de/ | /del/ | /,/) /año/? ([{myNER:"YEAR"}])) ,
#  action: ( Annotate($0, "myRule", "Rule$MMdeYYYY"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue", Concat(:case{ ($$2 != NIL) => $2[0].myNERnormalized, :else => "XXXX"}, "-", :case{ ($$1 != NIL) => $1[0].myNERnormalized, :else => "XX"})) )  ,
#  stage : 10  }
    
  
 #TODO: check normalization eu/EEUU, each part...
{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/(0?[1-9]|1[0-9]|2[0-9]|3[0-1])[\/|-]([1-9]|1[0-2])[\/|-]([1-2]\d\d\d)/),
result: ("DATE", Concat($$0.matchResults[0].word.group(3), "-0", $$0.matchResults[0].word.group(2), "-", $$0.matchResults[0].word.group(1)), "", "","Rule$DD-MM-YYYY") }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/(0?[1-9]|1[0-9]|2[0-9]|3[0-1])[\/|-](0[1-9])[\/|-]([1-2]\d\d\d)/),
result: ("DATE", Concat($$0.matchResults[0].word.group(3), "-", $$0.matchResults[0].word.group(2), "-", $$0.matchResults[0].word.group(1)), "", "", "Rule$DD-MM-YYYY") }


# How to normalize?
{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/(0?[1-9]|1[0-9]|2[0-9]|3[0-1])[\/|-]([1-9]|1[0-2])[\/|-](\d\d)/),
result: ("DATE", Concat("XX", $$0.matchResults[0].word.group(3), "-0", $$0.matchResults[0].word.group(2), "-", $$0.matchResults[0].word.group(1)), "", "", "Rule$DD-MM-YYYY") }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/(0?[1-9]|1[0-9]|2[0-9]|3[0-1])[\/|-](0[1-9])[\/|-](\d\d)/),
result: ("DATE", Concat("XX", $$0.matchResults[0].word.group(3), "-", $$0.matchResults[0].word.group(2), "-", $$0.matchResults[0].word.group(1)), "", "","Rule$DD-MM-YYYY") }





#####################
# Horas
##################### 


{ ruleType:   "tokens",
pattern: (([{lemma:/$Hoursmap/}]) [{lemma:"menos"}] ([{myNUM:"myNUMBER"} & {mySTValue:/([1-5][0-9])|[1-9]/}])),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexValue", Concat("T", HOURS_MENOS_MAP[$1[0].lemma], ":", MINUTES_MENOS_MAP[$2[0].lemma]) ) , Annotate($0, "myRule", "Rule$12menos15") )   ,
result: ("TIME", Concat("T", HOURS_MENOS_MAP[$1[0].lemma], ":", MINUTES_MENOS_MAP[$2[0].lemma]), "", "", "Rule$12menos15") }

{ ruleType:   "tokens",
pattern: (([{lemma:/$Hoursmap/}]) [{lemma:"y"}] [{lemma:"cuarto"}]),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexValue", Concat("T", HOURS_MENOS_MAP[$1[0].lemma], ":", MINUTES_MENOS_MAP[$2[0].lemma]) ) , Annotate($0, "myRule", "Rule$12ycuarto") )   ,
result: ("TIME", Concat("T", $1[0].mySTValue, ":15"), "", "", "Rule$12ycuarto") }

{ ruleType:   "tokens",
pattern: (([{lemma:/$Hoursmap/}]) [{lemma:"y"}] [{lemma:"media"}]),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexValue", Concat("T", HOURS_MENOS_MAP[$1[0].lemma], ":", MINUTES_MENOS_MAP[$2[0].lemma]) ) , Annotate($0, "myRule", "Rule$12ymedia") )   ,
result: ("TIME", Concat("T", $1[0].mySTValue, ":30"), "", "", "Rule$12ymedia") }

{ ruleType:   "tokens",
pattern: (([{lemma:/$Hoursmap/}]) [{lemma:"menos"}] [{lemma:"cuarto"}]),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexValue", Concat("T", HOURS_MENOS_MAP[$1[0].lemma], ":45" ) ) , Annotate($0, "myRule", "Rule$12menoscuarto") )   ,
result: ("TIME", Concat("T", HOURS_MENOS_MAP[$1[0].lemma], ":45" ), "", "", "Rule$12menoscuarto") }

{ ruleType:   "tokens",
pattern: ([{word:/[Ll][aA][sS]/}] ([{lemma:/$Hoursmap/}]) [{lemma:"y"}] ([{myNUM:"myNUMBER"} & {mySTValue:/([1-5][0-9])|[1-9]/}])),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexValue", Concat("T", HOURS_MENOS_MAP[$1[0].lemma], ":", MINUTES_MENOS_MAP[$2[0].lemma]) ) , Annotate($0, "myRule", "Rule$12y15") )   ,
result: ("TIME", Concat("T", $1[0].mySTValue, ":", $2[0].mySTValue), "", "", "Rule$12y15") }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/([1-9]|1[0-2])/ (/[P|p][M|m][.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/)),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexValue", Concat("T", PMHOUR_MAP[$$0.matchResults[0].word.group(1)], ":00") ) ),
result: ("TIME", Concat("T", PMHOUR_MAP[$$0.matchResults[0].word.group(1)], ":00"), "", "", "Rule$1_pm") }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/([1-9]|1[0-2])/ (/[A|a][M|m][.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/)),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexValue", Concat("T", $$0.matchResults[0].word.group(1), ":00") ) ),
result: ("TIME", Concat("T", $$0.matchResults[0].word.group(1), ":00"), "", "", "Rule$1_am") }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/([1-9]|1[0-2])[P|p][M|m][.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexValue", Concat("T", PMHOUR_MAP[$$0.matchResults[0].word.group(1)], ":00") ) ),
result: ("TIME", Concat("T", PMHOUR_MAP[$$0.matchResults[0].word.group(1)], ":00"), "", "", "Rule$1pm") }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/([1-9]|1[0-2])[A|a][M|m][.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexValue", Concat("T", $$0.matchResults[0].word.group(1), ":00") ) ),
result: ("TIME", Concat("T", $$0.matchResults[0].word.group(1), ":00"), "", "", "Rule$1am") }
  
{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/(0?[0-9]|1[0-9]|2[0-4]):([0-5][0-9])[.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexValue", Concat("T", $$0.matchResults[0].word.group(1),":", $$0.matchResults[0].word.group(2)) )),
result: ("TIME", Concat("T", $$0.matchResults[0].word.group(1),":", $$0.matchResults[0].word.group(2)), "", "", "Rule$1:30") }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/(0?[0-9]|1[0-9]|2[0-4])\.([0-5][0-9])[.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexValue", Concat("T", $$0.matchResults[0].word.group(1),":", $$0.matchResults[0].word.group(2)) )),
result: ("TIME", Concat("T", $$0.matchResults[0].word.group(1),":", $$0.matchResults[0].word.group(2)), "", "", "Rule$1.30") }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/(0?[0-9]|1[0-9]|2[0-4])[H|h]([0-5][0-9])?[.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexValue", Concat("T", $$0.matchResults[0].word.group(1),":", :case{($$0.matchResults[0].word.group(2) != NIL) => $$0.matchResults[0].word.group(2), :else => "00" }) )),
result: ("TIME", Concat("T", $$0.matchResults[0].word.group(1),":", :case{($$0.matchResults[0].word.group(2) != NIL) => $$0.matchResults[0].word.group(2), :else => "00" }), "", "", "Rule$1h30") }

{ ruleType:   "tokens",
matchWithResults: TRUE,
pattern: (/(0?[0-9]|1[0-9]|2[0-4])[H|h]([0-5][0-9])?[.,\/#!$%\^&\*;:{}=\-_`~()”“"…]?/),
action: ( Annotate($0, "myTType", "TIME"), Annotate($0, "timexValue", Concat("T", $$0.matchResults[0].word.group(1),":", :case{($$0.matchResults[0].word.group(2) != NIL) => $$0.matchResults[0].word.group(2), :else => "00" }) ) ),
result: ("TIME", Concat("T", $$0.matchResults[0].word.group(1),":", :case{($$0.matchResults[0].word.group(2) != NIL) => $$0.matchResults[0].word.group(2), :else => "00" }), "", "", "Rule$1h30") }

{ ruleType:   "tokens",
pattern: ([{word:/[Ll][aA][sS]/}] (/[1-9]|1[0-2]/) (?: [{lemma:"de"}] | [{lemma:"del"}] | [{lemma:"en"}] | [{lemma:"por"}])? [{pos:/AQ.*/} | {pos:/D.*/} | {pos:/CC/}]* ([{myNERnormalized:"PARTDAY"}])+),
result: ("TIME", Concat("T", :case{($2[0].timexValue == "AF") => PMHOUR_MAP[$1[0].lemma], :else => :case{($2[0].timexValue == "NI") => PMHOUR_MAP[$1[0].lemma], :else => :case{($2[0].timexValue == "EV") => PMHOUR_MAP[$1[0].lemma], :else => :case{($2[0].timexValue == "MI") => :case{($1[0].lemma != "12") => PMHOUR_MAP[$1[0].lemma], :else => $1[0].lemma }, :else => $1[0].lemma } } } }, ":00"), "", "", "Rule$3delatarde") }

{ ruleType:   "tokens",
matchedExpressionGroup: 1,
pattern: ([{word:/[Ll][aA][sS]/}] (/[1-9]|1[0-2]/) [!{pos:"NCFP000"}]),
result: ("TIME", Concat("T", $1[0].lemma , ":00"), "", "", "Rule$las3") }

{ ruleType:   "tokens",
matchedExpressionGroup: 1,
pattern: ([{word:/[Ll][aA][sS]/}] ([{myNUM:"myNUMBER"} & {mySTValue:/[1-9]|1[0-2]/} & !{pos:DN0CP0}]) [!{pos:"NCFP000"}]),
result: ("TIME", Concat("T", $1[0].mySTValue , ":00"), "", "", "Rule$las3") }

{ ruleType:   "tokens",
pattern: ([{word:/[Ll][aA][sS]/}] ([{myTType:"TIME"}]+) (?: [{lemma:"de"}] | [{lemma:"del"}] | [{lemma:"en"}] | [{lemma:"por"}])? [{pos:/AQ.*/} | {pos:/D.*/} | {pos:/CC/}]* ([{myNERnormalized:"PARTDAY"}])+),
result: ("TIME", Concat($1[0].timexValue, $2[0].timexValue), "", "", "Rule$3:20delatarde")  ,
  stage : 10  }

{ ruleType:   "tokens",
pattern: ([{word:/[Ll][aA][sS]/}] ([{myNUM:"myNUMBER"} & {mySTValue:/[1-9]|1[0-2]/} & !{pos:DN0CP0}]) (?: [{lemma:"de"}] | [{lemma:"del"}] | [{lemma:"en"}] | [{lemma:"por"}])? [{pos:/AQ.*/} | {pos:/D.*/} | {pos:/CC/}]* ([{myNERnormalized:"PARTDAY"}])+),
result: ("TIME", Concat("T", :case{($2[0].timexValue == "AF") => PMHOUR_MAP[$1[0].mySTValue], :else => :case{($2[0].timexValue == "NI") => PMHOUR_MAP[$1[0].mySTValue], :else => :case{($2[0].timexValue == "EV") => PMHOUR_MAP[$1[0].mySTValue], :else => :case{($2[0].timexValue == "MI") => :case{($1[0].mySTValue != "12") => PMHOUR_MAP[$1[0].mySTValue], :else => $1[0].mySTValue }, :else => $1[0].mySTValue } } } }, ":00"), "", "", "Rule$tresdelatarde") }
  
#composite:

#####################
# Number + TGranularity
#####################

# eg: horas
{ ruleType:   "tokens",
  pattern: ( [(/$TGranularity/ & {pos:/NC.*/})] ), # To avoid confusion with second (time measure unit and ordinal)
  action: ( Annotate($0, "myRule", "Rule$TGranularity"), Annotate($0, "myNER", "TGRANULARITY"), Annotate($0, "myNERnormalized", TGRANULARITY_MAP[$$0.text] ), Annotate($0, "myTType", $$0.text ) ) ,
  stage : 2  }

# eg: dos horas
{ ruleType:   "tokens",
  pattern: ( ([{myNUM:"myNUMBER"}]+) ([{myNER:"TGRANULARITY"}]) (?$plus [{lemma:"y"}] (?$added [{lemma:"medio"}] || [{word:/cuarto|CUARTO/}] || [{myNUM:"myNUMBER"} && {mySTValue:"03"}] [{word:/[Cc][Uu][Aa][Rr][Tt][Oo][Ss]/}]))? ),
  action: ( Annotate($0, "myRule", "Rule$NUMTGranularity"), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue",  Concat($1[0].mySTValue, TGRANULARITY_UNIT_MAP[$2[0].myNERnormalized], :case{($plus != NIL) => :case{($added[0].lemma == "medio") => HALF_DURATION_MAP[$2[0].myNERnormalized], ($added[0].mySTValue == "03") => TQUARTER_DURATION_MAP[$2[0].myNERnormalized], :else => QUARTER_DURATION_MAP[$2[0].myNERnormalized]}, :else => ""})), Annotate($0, DURATION_MAP[$2[0].myNERnormalized], $2[0].timexValue), Annotate($0, "Period", PERIOD_MAP[$2[0].myNERnormalized]) ) , 
  stage : 15  }
  
 # eg: varias/algunas horas
{ ruleType:   "tokens",
  pattern: ( ([{myNER:"INDEF"}]+) ([{myNER:"TGRANULARITY"}]) ),
  action: ( Annotate($0, "myRule", "Rule$INDEFTGranularity"), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue",  Concat("X", TGRANULARITY_UNIT_MAP[$2[0].myNERnormalized])), Annotate($0, DURATION_MAP[$2[0].myNERnormalized], $2[0].timexValue), Annotate($0, "Period", PERIOD_MAP[$2[0].myNERnormalized]) ) , 
  stage : 15  }
  
 # eg: las próximas horas/decadas (indef)
{ ruleType:   "tokens",
  pattern: ( ([{myNER:"FUT_REF_Adj"} & {pos:/A...P.*/}]+) (?$gran [{myNER:"[TD]GRANULARITY"}]) ),
  action: ( Annotate($0, "myRule", "Rule$proximasGranularity"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  "FUTURE_REF") ) , 
  stage : 15  }
  
  { ruleType:   "tokens",
  pattern: ( ([{myNER:"PAS_REF_Adj"} & {pos:/A...P.*/}]+) (?$gran [{myNER:"[TD]GRANULARITY"}]) ),
  action: ( Annotate($0, "myRule", "Rule$anterioresGranularity"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  "PAST_REF") ) , 
  stage : 15  }
  
 # eg: las horas que vienen (indef)
{ ruleType:   "tokens",
  pattern: ( (?$gran [{myNER:"TGRANULARITY"}]) ([{myNER:"FUT_REF_Adj"} & {pos:/A...P.*/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$Granularityqueviene"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  "FUTURE_REF") ) , 
  stage : 15  }
  
 { ruleType:   "tokens",
  pattern: ( (?$gran [{myNER:"TGRANULARITY"}]) ([{myNER:"PAS_REF_Adj"} & {pos:/A...P.*/}]+) ),
  action: ( Annotate($0, "myRule", "Rule$Granularityanteriores"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  "PAST_REF") ) , 
  stage : 15  }
 
 #TODO: poco claro como habria que normalizar esto con horas...
 # eg: la próxima hora (anchor)
{ ruleType:   "tokens",
  pattern: ( ([{myNER:"FUT_REF_Adj"} & {pos:/A...S.*/}]+) (?$gran [{myNER:"GRANULARITY"}]+) ),
  action: ( Annotate($0, "myRule", "Rule$proximoGranularity"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("anchor(TODAY,+1,", DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")")) ) , 
  stage : 15  }
  
  { ruleType:   "tokens",
  pattern: ( ([{myNER:"PAS_REF_Adj"} & {pos:/A...S.*/}]+) (?$gran [{myNER:"GRANULARITY"}]+) ),
  action: ( Annotate($0, "myRule", "Rule$anteriorGranularity"), Annotate($0, "timexType", "DATE"), Annotate($0, "timexValue",  Concat("anchor(TODAY,-1,", DGRANULARITY_UNIT_MAP[$gran[0].myNERnormalized],")")) ) , 
  stage : 15  }
  
# eg: una hora
#{ ruleType:   "tokens",
#  pattern: ( ([{lemma:"uno"}]) ([{myNER:"TGRANULARITY"}]) ),
#      action: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue",  Concat($1[0].mySTValue, TGRANULARITY_UNIT_MAP[$2[0].myNERnormalized])), Annotate($0, "MyRule",  "Rule$unTGranularity"), Annotate($0, DURATION_MAP[$2[0].myNERnormalized], $2[0].timexValue ), Annotate($0, "Period", PERIOD_MAP[$2[0].myNERnormalized]) ) , 
#  stage : 15  }

# eg: media hora /cuarto de hora
 { ruleType:   "tokens",
   pattern: ( (?$added [{lemma:"medio"}] || [{word:/[Cc][Uu][Aa][Rr][Tt][Oo]/}] [{lemma:"de"}] || [{myNUM:"myNUMBER"} && {mySTValue:"03"}] [{word:/[Cc][Uu][Aa][Rr][Tt][Oo][Ss]/}] [{lemma:"de"}]) (?$granu [{myNER:"TGRANULARITY"}]+) ),
      action: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$MediaHora"), Annotate($0, "timexValue", :case{($added[0].lemma == "medio") => HALF_DURATION_MAP[$granu[0].myNERnormalized], ($added[0].mySTValue == "03") => TQUARTER_DURATION_MAP[$granu[0].myNERnormalized], :else => QUARTER_DURATION_MAP[$granu[0].myNERnormalized]}), Annotate($0, DURATION_MAP[$granu[0].myNERnormalized], $granu[0].timexValue), Annotate($0, "Period", :case{($granu[0].myNERnormalized == "DAY") => PERIOD_MAP["HOUR"], :else => PERIOD_MAP[$granu[0].myNERnormalized]}) ) , 
	  stage : 14  }

  
  
#####################
# Number + DGranularity
##################### 
 
  # eg: dos dias
{ ruleType:   "tokens",
  pattern: ( ([{myNUM:"myNUMBER"}]+)  ([{myNER:"DGRANULARITY"}]+) (?$plus [{lemma:"y"}] (?$added [{lemma:"medio"}] || [{word:/[Cc][Uu][Aa][Rr][Tt][Oo]/}] || [{myNUM:"myNUMBER"} && {mySTValue:"03"}] [{word:/[Cc][Uu][Aa][Rr][Tt][Oo][Ss]/}]))? ),
    action: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$DosDias"), Annotate($0, "timexValue",  Concat($1[0].mySTValue,DGRANULARITY_UNIT_MAP[$2[0].myNERnormalized], :case{($plus != NIL) => :case{($added[0].lemma == "medio") => HALF_DURATION_MAP[$2[0].myNERnormalized], ($added[0].mySTValue == "03") => TQUARTER_DURATION_MAP[$2[0].myNERnormalized], :else => QUARTER_DURATION_MAP[$2[0].myNERnormalized]}, :else => ""})), Annotate($0, DURATION_MAP[$2[0].myNERnormalized], $2[0].timexValue), Annotate($0, "Period", PERIOD_MAP[$2[0].myNERnormalized]) ) , 
  stage : 15  }
 
 { ruleType:   "tokens",
  pattern: ( ([{myNER:"INDEF"}]+) ([{myNER:"DGRANULARITY"}]+) ),
  action: ( Annotate($0, "myRule", "Rule$INDEFDGranularity"), Annotate($0, "timexType", "DURATION"), Annotate($0, "timexValue",  Concat("X", DGRANULARITY_UNIT_MAP[$2[0].myNERnormalized])), Annotate($0, DURATION_MAP[$2[0].myNERnormalized], $2[0].timexValue), Annotate($0, "Period", PERIOD_MAP[$2[0].myNERnormalized]) ) , 
  stage : 15  }
 
# eg: medio dia /cuarto de año
 { ruleType:   "tokens",
   pattern: ( (?$added [{lemma:"medio"}] || [{word:/[Cc][Uu][Aa][Rr][Tt][Oo]/}] [{lemma:"de"}] || [{myNUM:"myNUMBER"} && {mySTValue:"03"}] [{word:/cuartos|CUARTOS/}] /de/) (?$granu [{myNER:"DGRANULARITY"}]+) ),
      action: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$MedioDia"), Annotate($0, "timexValue", :case{($added[0].lemma == "medio") => HALF_DURATION_MAP[$granu[0].myNERnormalized], ($added[0].mySTValue == "03") => TQUARTER_DURATION_MAP[$granu[0].myNERnormalized], :else => QUARTER_DURATION_MAP[$granu[0].myNERnormalized]}), Annotate($0, DURATION_MAP[$granu[0].myNERnormalized], $granu[0].timexValue), Annotate($0, "Period", PERIOD_MAP[$granu[0].myNERnormalized]) ) , 
	  stage : 14  }
  
# eg: dos veces
{ ruleType:   "tokens",
  pattern: ( ([{myNUM:"myNUMBER"}]+) ([{lemma:"vez"}]) ),
  action: ( Annotate($0, "myRule", "Rule$numVeces"), Annotate($0, "myNER", "TIMES"), Annotate($0, "myNERnormalized", Concat($1[0].myNERnormalized,"X")) )  ,
  stage : 5  }
  
# eg: una vez
{ ruleType:   "tokens",
  pattern: ( ([{lemma:"uno"}]) ([{lemma:"vez"}]) ),
  action: ( Annotate($0, "myRule", "Rule$unaVez"), Annotate($0, "myNER", "TIMES"), Annotate($0, "myNERnormalized", "1X") )  ,
  stage : 5  }
  
  
   
{ ruleType: "composite",
priority: 2.0,
  pattern: ( [{lemma:"el"}]? (?: [{myNER:"WEEKDAY"}] /,/? [{lemma:"a"}]?)? [{lemma:"día"}]? ([{myNER:"DAYMONTH"} | {myNER:"MONTHN"} | ({myNUM:"myNUMBER"} & {mySTValue:/([1-2][0-9])|0?[1-9]|3[0-1]/})])? (?: [{lemma:"de"}] | [{lemma:"del"}])? [{lemma:"mes"}]? [{lemma:"de"}]? ([{myNER:"MONTHS"}]) (?: (?: [{lemma:"de"} | {lemma:"del"} | /,/])? [{lemma:"año"}]?)?  ([{myNER:"YEAR"}])?) ,
  action: ( :case{ ($$1 != NIL || $$3 != NIL  ) => (Annotate($0, "myDateDay", :case{ ($$1 != NIL) => $1[0].myNERnormalized, :else => "XX"}), Annotate($0, "myDateMonth", :case{ ($$2 != NIL) => $2[0].myNERnormalized, :else => "XX"}),Annotate($0, "myDateYear", :case{ ($$3 != NIL) => $3[0].myNERnormalized, :else => "XXXX"}));} ), 
  result: ( "DATE", Concat(:case{ ($$3 != NIL) => $3[0].myNERnormalized, :else => "XXXX"}, "-", :case{ ($$2 != NIL) => $2[0].myNERnormalized, :else => "XX"}, "-", :case{ ($$1 != NIL) => $1[0].myNERnormalized, :else => "XX"}), "", "", "Rule$DDdeMMdeYYYY")  ,
  stage : 25  } 
  
{ ruleType: "composite",
matchedExpressionGroup: 1,
priority: 3.0,
  pattern: ( (?: (?: [{lemma:"en"}]?  [{lemma:"el"}] [{lemma:"año"}]?) | (?: [{lemma:"en"} | {lemma:"año"}]))  ([{myNER:"YEAR"}]+) (?:[!{pos:/NC.*/}])) ,
  action: ( Annotate($0, "myDateYear", :case{ ($$1 != NIL) => $1[0].myNERnormalized, :else => "XXXX"}) ),
  result: ( "DATE", $1[0].myNERnormalized,  "", "", "Rule$EnElAñoYYYY")  ,
  stage : 200  }  

# cuidado con el entre
# Sucesion de dias
{ ruleType: "tokens",
  pattern: ( (?: [{lemma:"el"}]?  [{myNER:"DAYMONTH"} | {myNER:"MONTHN"} | ({myNUM:"myNUMBER"} & {mySTValue:/([1-2][0-9])|0?[1-9]|3[0-1]/})] (?: /,/ | /y/))+  [{lemma:"el"}]? ([{myNER:"DAYMONTH"} | {myNER:"MONTHN"} | ({myNUM:"myNUMBER"} & {mySTValue:/([1-2][0-9])|0?[1-9]|3[0-1]/})]) ) ,
  action: ( Annotate($0, "myRule", "Rule$el2yel3deoctubre"), Annotate($0, "myDateMonth", $1[0].myDateMonth), Annotate($0, "myDateYear", $1[0].myDateYear)),
  stage : 100  }

{ ruleType: "composite",
 matchedExpressionGroup: 1,
  pattern: ( ([{lemma:"el"}]?  (?: [{myNER:"WEEKDAY"}] /,/? [{lemma:"a"}]?)? (?$dig [{myNER:"DAYMONTH"} | {myNER:"MONTHN"} | ({myNUM:"myNUMBER"} & {mySTValue:/([1-2][0-9])|0?[1-9]|3[0-1]/})])) (?: [{lemma:"y"}] | /,/)  [{lemma:"el"}]? ([{myRule:/Rule\$DDdeMMdeYYYY|Rule\$DDdeMMdeYYYYCom/}]) ) ,
  action: ( Annotate($1, "myRule", "Rule$DDdeMMdeYYYYCom"), Annotate($1, "timexType", "DATE"), Annotate($1, "myDateDay", $dig[0].myNERnormalized)),
  result: ( "DATE", Concat($dig[0].myDateYear, "-", $dig[0].myDateMonth, "-", $dig[0].myDateDay), "", "","Rule$DDdeMMdeYYYYCom")  ,
  stage : 100  }  


# Sucesion de meses
{ ruleType: "tokens",
  pattern: ( (?:  [{myNER:"MONTHS"}] (?: [{lemma:"y"}] | /,/))+  ([{myNER:"MONTHS"}]) ) ,
  action: ( Annotate($0, "myRule", "Rule$octubreydiciembre"), Annotate($0, "myDateYear", $1[0].myDateYear)),
  stage : 100  }

{ ruleType: "composite",
 matchedExpressionGroup: 1,
 priority: 1.0,
  pattern: ( ([{myNER:"MONTHS"}]) (?: [{lemma:"y"}] | /,/) ([{myRule:/Rule\$DDdeMMdeYYYY|Rule\$DDdeMMdeYYYYCom/}]) ) ,
  action: ( Annotate($1, "myRule", "Rule$DDdeMMdeYYYYCom"), Annotate($1, "timexType", "DATE"), Annotate($1, "myDateMonth", $1[0].myNERnormalized)),
  result: ( "DATE", Concat($1[0].myDateYear, "-", $1[0].myDateMonth), "", "", "Rule$DDdeMMdeYYYYCom")  ,
  stage : 100  } 


# Sucesion de duraciones
{ ruleType: "composite",
 priority: 1.0,
  pattern: ( [{timexType:"DURATION"}]* ([{timexType:"DURATION"}]) (?: [{lemma:"y"}] | /,/) [{timexType:"DURATION"}]* ([{timexType:"DURATION"}]) ) ,
  action: ( Annotate($0, "timexType", "DURATION"), Annotate($0, "myRule", "Rule$1añoy2meses"), Annotate($0, DURATION_MAP[$1[0].myNERnormalized], $1[0].timexValue) , Annotate($0, DURATION_MAP[$2[0].myNERnormalized], $2[0].timexValue), Annotate($0, "Period", :case{($1[0].Period == "PT" || $2[0].Period == "PT") => "PT", :else => "P" }) ),
  stage : 100  }
  
{ ruleType: "composite",
 priority: 1.0,
  pattern: ( ([{myRule:"Rule$1añoy2meses"}]+) ) ,
  result: ( "DURATION", 
  Concat($0[0].Period, :case {($0[1].myDurationDecade == NIL ) => "" , :else => $0[1].myDurationDecade}, :case {($0[1].myDurationYear == NIL ) => "" , :else => $0[1].myDurationYear}, :case {($0[1].myDurationMonth == NIL ) => "" , :else => $0[1].myDurationMonth}, :case {($0[1].myDurationWeek == NIL ) => "" , :else => $0[1].myDurationWeek}, :case {($0[1].myDurationWeekend == NIL ) => "" , :else => $0[1].myDurationWeekend}, :case {($0[1].myDurationDay == NIL ) => "" , :else => $0[1].myDurationDay}, :case {($0[1].myDurationHour == NIL ) => "" , :else => $0[1].myDurationHour}, :case {($0[1].myDurationMinute == NIL ) => "" , :else => $0[1].myDurationMinute}, :case {($0[1].myDurationSecond == NIL ) => "" , :else => $0[1].myDurationSecond}), "", "", "Rule$1añoy2meses")  ,
  stage : 199  }
  

  
  
  
####### ISOLATED
  
  # Weekday isolated
{ ruleType:   "composite",
  pattern: ( [{myNER:"WEEKDAY"}]  ),
  result: ( "DATE", Concat($0[0].timexValue,""), "", "", "Rule$WEEKL" ) ,
  stage : 200  } 
  
# Month isolated
{ ruleType:   "composite",
  pattern: ( [{myNER:"MONTHS"}]  ),
  result: ( "DATE", Concat($0[0].timexValue,""), "", "", "Rule$MONTHS" ) ,
  stage : 200  } 
  
  # Weekend isolated
{ ruleType:   "composite",
  pattern: ( [{myTType:"finsemana"}]+  ),
  result: ( "DATE", Concat($0[0].timexValue,""), "", "", "Rule$finsemana" ) ,
  stage : 200  } 
  
    # anchored isolated
{ ruleType:   "composite",
  pattern: ( [{timexValue:/anchor.*/}]+  ),
  result: ( "DATE", Concat($0[0].timexValue,""), "", "", $0[0].myRule ) ,
  stage : 200  } 
  
   # duration
 { ruleType:   "composite",
   pattern: ( [{timexType:"DURATION"}]+  ),
   result: ( "DURATION", Concat($0[1].Period ,$0[0].timexValue), "", "", $0[0].myRule ) ,
   stage : 200  } 
  
     # time
{ ruleType:   "composite",
  pattern: ( [{timexType:"TIME"}]+  ),
  result: ( "TIME", Concat($0[1].timexValue,""), "", "", $0[0].myRule ) ,
  stage : 200  } 
  
      # set
{ ruleType:   "composite",
  pattern: ( [{timexType:"SET"}]+  ),
  result: ( "SET", Concat($0[1].timexValue,""), :case{($0[0].timexFreq != NIL) => Concat($0[0].timexFreq, ""), :else => ""} , :case{($0[0].timexQuant != NIL) => Concat($0[0].timexQuant, ""), :else => ""}, $0[0].myRule ) ,
  stage : 199  } 
  
        # dateRefs
{ ruleType:   "composite",
  pattern: ( [{timexType:"DATE"} && {timexValue:/.+_REF/}]+  ),
  result: ( "DATE", Concat($0[1].timexValue,""), "", "", $0[0].myRule ) ,
  stage : 200  } 
  
        # date en el año
{ ruleType:   "composite",
  pattern: ( ([{timexType:"DATE"} && {myRule:"Rule$EnElAñoMyNumber"}]+)  ),
  result: ( "DATE", Concat($1[0].timexValue,""), "", "", "Rule$EnElAñoMyNumber" ) ,
  stage : 200  } 
  
  
  # NOT USEFUL FOR THE LEGAL DOMAIN
  
  # adj proximo
{ ruleType:   "composite",
  pattern: ( [{pos:/AQ.*/} && {lemma:/próximo|futuro/}]+  ),
  result: ( "DATE", "FUTURE_REF", "", "", "Rule$AdjProximo" ) ,
  stage : 200  }   

  # adj reciente
{ ruleType:   "composite",
  pattern: ( [{pos:/AQ.*/} && {lemma:/reciente|pasado|antiguo/}]+  ),
  result: ( "DATE", "PAST_REF", "", "", "Rule$AdjReciente" ) ,
  stage : 200  }     


# Intervalo
  
#

